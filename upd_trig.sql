create or replace TRIGGER DOP5
AFTER ALTER OR CREATE
ON SCHEMA
DECLARE
  JOB_NUM NUMBER;
  STR VARCHAR2(500);
  NAME_STR VARCHAR2(500);
BEGIN
  IF (ORA_SYSEVENT = 'ALTER') THEN
    IF (INSTR(UPPER(ORA_DICT_OBJ_NAME), 'SYS_') = 0) THEN
      IF (ORA_DICT_OBJ_TYPE = 'TABLE') THEN
        DBMS_OUTPUT.PUT_LINE('Обновлена таблица ' || ORA_DICT_OBJ_NAME || ', запуск создания триггера.');
        STR := 'ALTER TABLE ' || ORA_DICT_OBJ_NAME || ' DISABLE ALL TRIGGERS;';
        EXECUTE IMMEDIATE STR;
          STR := 'BEGIN CREATE_TRIGGER(' || q'[']' || ORA_DICT_OBJ_NAME  || q'[']' || '); END;';
          NAME_STR := 'ALTTG_' || ORA_DICT_OBJ_NAME;
          DBMS_SCHEDULER.CREATE_JOB(
            JOB_NAME => NAME_STR,
            JOB_TYPE => 'PLSQL_BLOCK',
            JOB_ACTION => STR,
            START_DATE => SYSDATE + 1 / 3600,
            REPEAT_INTERVAL => NULL,
            ENABLED => TRUE,
            END_DATE => SYSTIMESTAMP + 50 / 3600
          );
      END IF;
    END IF;
  ELSIF (ORA_SYSEVENT = 'CREATE') THEN
    IF (INSTR(UPPER(ORA_DICT_OBJ_NAME), 'SYS_') = 0) THEN
      IF (ORA_DICT_OBJ_TYPE = 'TABLE') THEN      
        DBMS_OUTPUT.PUT_LINE('Создана таблица ' || ORA_DICT_OBJ_NAME || ', запуск создания триггера.');
        STR := 'BEGIN CREATE_TRIGGER(' || q'[']' || ORA_DICT_OBJ_NAME  || q'[']' || '); END;';
        NAME_STR := 'CRTTG_' || ORA_DICT_OBJ_NAME;
        DBMS_SCHEDULER.CREATE_JOB(
          JOB_NAME => NAME_STR,
          JOB_TYPE => 'PLSQL_BLOCK',
          JOB_ACTION => STR,
          START_DATE => SYSDATE + 1 / 3600,
          REPEAT_INTERVAL => NULL,
          ENABLED => TRUE,
          END_DATE => SYSTIMESTAMP + 50 / 3600
        );
      END IF;
    END IF;
  END IF;
END DOP5;

--Код процедуры CREATE_TRIGGER:

create or replace procedure CREATE_TRIGGER (TRG_TABLE VARCHAR2) AUTHID CURRENT_USER
is
    TEMP VARCHAR2(2000);
    TEMP_NUMBER NUMBER(2) := 0;
    
    TYPE REF_CURSOR_TEXT_T IS REF CURSOR;
    REF_CURSOR_TEXT REF_CURSOR_TEXT_T;
      
    TYPE COLUMNS_REFERENCES_RECORD IS RECORD (TRG_TABLE VARCHAR2(128), CONSTRAINT_TO_ALTER VARCHAR2(128), COLUMS_LISTAGG_FOREIGN VARCHAR2(644), COLUMS_LISTAGG_REFERENCES VARCHAR2(644));
    TYPE COLUMNS_REFERENCES_TYPE IS TABLE OF COLUMNS_REFERENCES_RECORD INDEX BY BINARY_INTEGER;
    COLUMNS_REFERENCES COLUMNS_REFERENCES_TYPE;
    
    TYPE TEMP_VARCHAR IS TABLE OF VARCHAR(100) INDEX BY BINARY_INTEGER;
    COLS_IN_PK TEMP_VARCHAR;
    FOREIGN_TABLE TEMP_VARCHAR;
    COLS_IN_PK_LISTAGG VARCHAR2(500);
    
    TRIGGER_TEXT VARCHAR2(20000);
    
    TYPE FOREIGN_COLUMNS_RECORD IS RECORD (TRG_TABLE VARCHAR2(30), COL_B VARCHAR2(30), COL_REF VARCHAR2(30));
    TYPE FOREIGN_COLUMNS_TYPE IS TABLE OF FOREIGN_COLUMNS_RECORD INDEX BY BINARY_INTEGER;
    FOREIGN_COLUMNS FOREIGN_COLUMNS_TYPE;

    TYPE COLUMNS_IN_REF_TYPE0 IS TABLE OF VARCHAR2(30) INDEX BY VARCHAR2(30);
    TYPE TAB_COLUMNS_IN_REF_TYPE IS TABLE OF COLUMNS_IN_REF_TYPE0 INDEX BY VARCHAR2(30);
    COLUMNS_IN_REF_TABLE TAB_COLUMNS_IN_REF_TYPE;
    
    UPDATE_TABLE_SET VARCHAR2(500) := '';
    UPDATE_TABLE_WHERE VARCHAR2(500) := '';

  BEGIN
    DBMS_OUTPUT.PUT_LINE('Вход в процедуру, таблица: '|| TRG_TABLE);
    
    FOR K IN (SELECT CONSTRAINT_NAME FROM USER_CONSTRAINTS WHERE TABLE_NAME = UPPER(TRG_TABLE) AND CONSTRAINT_TYPE IN ('P', 'U')) LOOP
    
      TEMP_NUMBER := TEMP_NUMBER + 1;
    
      TEMP := q'[SELECT DISTINCT CON.TABLE_NAME, CON.CONSTRAINT_NAME,
      TRIM(LISTAGG(COL.COLUMN_NAME, ', ') WITHIN GROUP (ORDER BY COL.POSITION) OVER(PARTITION BY CON.CONSTRAINT_NAME)),
      TRIM(LISTAGG(COL1.COLUMN_NAME, ', ') WITHIN GROUP (ORDER BY COL.POSITION) OVER(PARTITION BY CON.CONSTRAINT_NAME))
      FROM USER_CONSTRAINTS CON
      INNER JOIN USER_CONS_COLUMNS COL ON COL.CONSTRAINT_NAME = CON.CONSTRAINT_NAME
      INNER JOIN USER_CONS_COLUMNS COL1 ON COL1.CONSTRAINT_NAME = CON.R_CONSTRAINT_NAME AND COL1.POSITION = COL.POSITION
      WHERE CON.CONSTRAINT_TYPE = 'R' AND CON.R_CONSTRAINT_NAME = ']' || K.CONSTRAINT_NAME || q'[']';
    
      OPEN REF_CURSOR_TEXT FOR TEMP;
      FETCH REF_CURSOR_TEXT BULK COLLECT INTO COLUMNS_REFERENCES;
      CLOSE REF_CURSOR_TEXT;
      
      IF COLUMNS_REFERENCES.COUNT = 0 THEN
        CONTINUE;
      END IF;
      
      FOR I IN COLUMNS_REFERENCES.FIRST..COLUMNS_REFERENCES.LAST LOOP
        EXECUTE IMMEDIATE 'ALTER TABLE ' || COLUMNS_REFERENCES(I).TRG_TABLE || ' DROP CONSTRAINT ' || COLUMNS_REFERENCES(I).CONSTRAINT_TO_ALTER;
        EXECUTE IMMEDIATE 'ALTER TABLE ' || COLUMNS_REFERENCES(I).TRG_TABLE || ' ADD CONSTRAINT ' || COLUMNS_REFERENCES(I).CONSTRAINT_TO_ALTER || ' FOREIGN KEY (' || COLUMNS_REFERENCES(I).COLUMS_LISTAGG_FOREIGN || ') REFERENCES ' || TRG_TABLE || '(' || COLUMNS_REFERENCES(I).COLUMS_LISTAGG_REFERENCES || ') DEFERRABLE INITIALLY DEFERRED';
        EXECUTE IMMEDIATE 'SET CONSTRAINT ' || COLUMNS_REFERENCES(I).CONSTRAINT_TO_ALTER || ' DEFERRED';
      END LOOP;
    
      TEMP := q'[SELECT COL.COLUMN_NAME FROM USER_CONSTRAINTS CON INNER JOIN USER_CONS_COLUMNS COL ON COL.CONSTRAINT_NAME = CON.CONSTRAINT_NAME WHERE CON.CONSTRAINT_NAME = ']' || K.CONSTRAINT_NAME || q'[']';
      
      OPEN REF_CURSOR_TEXT FOR TEMP;
      FETCH REF_CURSOR_TEXT BULK COLLECT INTO COLS_IN_PK;
      CLOSE REF_CURSOR_TEXT;
      
      FOR I IN COLS_IN_PK.FIRST..COLS_IN_PK.LAST LOOP
        COLS_IN_PK_LISTAGG := COLS_IN_PK_LISTAGG || COLS_IN_PK(I);
        IF I != COLS_IN_PK.LAST THEN COLS_IN_PK_LISTAGG := COLS_IN_PK_LISTAGG || ', '; END IF;
      END LOOP;
      
      TRIGGER_TEXT := 'CREATE OR REPLACE TRIGGER CASCADE_' || TRG_TABLE || '_' || TEMP_NUMBER || '
      FOR UPDATE OF ' || COLS_IN_PK_LISTAGG || '  ON ' || TRG_TABLE ||  '
      COMPOUND TRIGGER
      TYPE RECS_TYPE IS TABLE OF ' || TRG_TABLE ||  '%ROWTYPE;
      NEW_RECS RECS_TYPE;
      OLD_RECS RECS_TYPE;
      BEFORE STATEMENT IS
      BEGIN
        SELECT *
        BULK COLLECT INTO OLD_RECS
        FROM ' || TRG_TABLE ||  ';
      END BEFORE STATEMENT;
      ';
      
      TEMP := q'[SELECT COL.TABLE_NAME AS TRG_TABLE_NAME, COL1.COLUMN_NAME AS COL_B, COL.COLUMN_NAME AS COL_REF
      FROM USER_CONSTRAINTS CON
      INNER JOIN USER_CONS_COLUMNS COL ON COL.CONSTRAINT_NAME = CON.CONSTRAINT_NAME
      INNER JOIN USER_CONS_COLUMNS COL1 ON COL1.CONSTRAINT_NAME  = CON.R_CONSTRAINT_NAME  AND COL.POSITION = COL1.POSITION
      WHERE CON.CONSTRAINT_TYPE = 'R' AND CON.R_CONSTRAINT_NAME = ']' || K.CONSTRAINT_NAME || q'[']';
      
      OPEN REF_CURSOR_TEXT FOR TEMP;
      FETCH REF_CURSOR_TEXT BULK COLLECT INTO FOREIGN_COLUMNS;
      CLOSE REF_CURSOR_TEXT;
            
      FOR I IN FOREIGN_COLUMNS.FIRST..FOREIGN_COLUMNS.LAST LOOP
        COLUMNS_IN_REF_TABLE(FOREIGN_COLUMNS(I).TRG_TABLE)(FOREIGN_COLUMNS(I).COL_B) := FOREIGN_COLUMNS(I).COL_REF;
      END LOOP;
      
      TEMP := q'[SELECT CON.TABLE_NAME FROM USER_CONSTRAINTS CON WHERE CON.CONSTRAINT_TYPE = 'R' AND CON.R_CONSTRAINT_NAME = ']' || K.CONSTRAINT_NAME || q'[']';
      OPEN REF_CURSOR_TEXT FOR TEMP;
      FETCH REF_CURSOR_TEXT BULK COLLECT INTO FOREIGN_TABLE;
      CLOSE REF_CURSOR_TEXT;
  
      TRIGGER_TEXT := TRIGGER_TEXT || '
      AFTER STATEMENT IS BEGIN 
      SELECT *
      BULK COLLECT INTO NEW_RECS
      FROM ' || TRG_TABLE ||  ';
      ';
      
      FOR I IN FOREIGN_TABLE.FIRST..FOREIGN_TABLE.LAST LOOP
        TRIGGER_TEXT := TRIGGER_TEXT || '
        FOR I IN NEW_RECS.FIRST..NEW_RECS.LAST LOOP ';
        TRIGGER_TEXT := TRIGGER_TEXT || '
        UPDATE ' || FOREIGN_TABLE(I);
        TRIGGER_TEXT := TRIGGER_TEXT || ' SET ';
        
        UPDATE_TABLE_SET := '';
        UPDATE_TABLE_WHERE := '';
  
        FOR J IN COLS_IN_PK.FIRST..COLS_IN_PK.LAST LOOP
          UPDATE_TABLE_SET := UPDATE_TABLE_SET || COLUMNS_IN_REF_TABLE(FOREIGN_TABLE(I))(COLS_IN_PK(J)) || ' = NEW_RECS(I).' || COLS_IN_PK(J);
          UPDATE_TABLE_WHERE := UPDATE_TABLE_WHERE || COLUMNS_IN_REF_TABLE(FOREIGN_TABLE(I))(COLS_IN_PK(J)) || ' = OLD_RECS(I).' || COLS_IN_PK(J);
          IF J != COLS_IN_PK.LAST THEN
            UPDATE_TABLE_SET := UPDATE_TABLE_SET || ', ';
            UPDATE_TABLE_WHERE := UPDATE_TABLE_WHERE || ' AND ';
          END IF;
        END LOOP;
  
        TRIGGER_TEXT := TRIGGER_TEXT || UPDATE_TABLE_SET || ' WHERE ' || UPDATE_TABLE_WHERE;
        TRIGGER_TEXT := TRIGGER_TEXT || '; END LOOP; ';
      END LOOP;
  
      TRIGGER_TEXT := TRIGGER_TEXT || '
      END AFTER STATEMENT;
      END;';
      
      /*DBMS_OUTPUT.PUT_LINE(TRIGGER_TEXT);*/
  
      EXECUTE IMMEDIATE TRIGGER_TEXT;
      
      FOR I IN FOREIGN_TABLE.FIRST..FOREIGN_TABLE.LAST LOOP
        IF UPPER(FOREIGN_TABLE(I)) != UPPER(TRG_TABLE) THEN
          CREATE_TRIGGER(FOREIGN_TABLE(I));
        END IF;
      END LOOP;
      
      DBMS_OUTPUT.PUT_LINE('Триггер CASCADE_' || TRG_TABLE || '_' || TEMP_NUMBER || ' успешно создан!');
      
    END LOOP;

END CREATE_TRIGGER;
